name: Daily Fire Data Archive

on:
  schedule:
    - cron: "10 9 * * *"  # Daily at 09:10 UTC
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: fire-archive-${{ github.ref }}
  cancel-in-progress: false

jobs:
  archive:
    runs-on: ubuntu-latest
    env:
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install requests

      - name: Archive fire data
        shell: python
        run: |
          """Daily archive of fire data from CWFIS and ERD sources."""
          import os
          import json
          import time
          from datetime import datetime
          from zoneinfo import ZoneInfo
          import requests

          # =============================================================================
          # Configuration
          # =============================================================================

          ATLANTIC_TZ = ZoneInfo("America/Moncton")
          NB_BBOX = (-69.05, 44.56, -63.70, 48.07)  # minx, miny, maxx, maxy

          ARCHIVE_ROOT = "archive"
          CWFIS_DIR = os.path.join(ARCHIVE_ROOT, "cwfis")
          ERD_DIR = os.path.join(ARCHIVE_ROOT, "erd")

          TIMEOUT = 90
          RETRIES = 3

          CWFIS_WFS = "https://cwfis.cfs.nrcan.gc.ca/geoserver/public/ows"

          DATASETS = {
              # CWFIS WFS layers
              "24_hour_spots": {"type": "cwfis", "layer": "public:hotspots_last24hrs", "dir": CWFIS_DIR},
              "fire_perimeters": {"type": "cwfis", "layer": "public:m3_polygons_current", "dir": CWFIS_DIR},
              # ERD ArcGIS layers
              "active_fires": {"type": "erd", "url": "https://gis-erd-der.gnb.ca/gisserver/rest/services/Fire_Dashboards/Public_Fires/MapServer/0/query", "dir": ERD_DIR},
              "out_fires": {"type": "erd", "url": "https://gis-erd-der.gnb.ca/gisserver/rest/services/Fire_Dashboards/Public_Fires/MapServer/1/query", "dir": ERD_DIR},
              "fire_locations": {"type": "erd", "url": "https://gis-erd-der.gnb.ca/gisserver/rest/services/New_Brunswick_Fires/New_Brunswick_Fire_Locations/FeatureServer/0/query", "dir": ERD_DIR},
          }

          # =============================================================================
          # Helpers
          # =============================================================================

          def log(msg: str) -> None:
              ts = time.strftime("%H:%M:%S", time.gmtime())
              print(f"[{ts}] {msg}", flush=True)

          def fetch_json(url: str, params: dict, label: str) -> dict:
              """Fetch JSON with retries."""
              for attempt in range(1, RETRIES + 1):
                  try:
                      log(f"  {label}: attempt {attempt}")
                      r = requests.get(url, params=params, timeout=TIMEOUT)
                      r.raise_for_status()
                      return r.json()
                  except Exception as e:
                      log(f"  {label}: error - {e}")
                      time.sleep(1 * attempt)
              return {}

          def empty_fc() -> dict:
              return {"type": "FeatureCollection", "features": []}

          def esri_to_geojson(esri: dict) -> dict:
              """Convert ESRI JSON to GeoJSON."""
              features = []
              for f in esri.get("features", []):
                  geom = f.get("geometry")
                  gj_geom = None
                  
                  if geom:
                      if "x" in geom and "y" in geom:
                          gj_geom = {"type": "Point", "coordinates": [geom["x"], geom["y"]]}
                      elif "rings" in geom:
                          rings = geom["rings"] or []
                          gj_geom = {"type": "Polygon", "coordinates": rings} if len(rings) == 1 else {"type": "MultiPolygon", "coordinates": [[r] for r in rings]}
                      elif "paths" in geom:
                          paths = geom["paths"] or []
                          gj_geom = {"type": "LineString", "coordinates": paths[0]} if len(paths) == 1 else {"type": "MultiLineString", "coordinates": paths}
                  
                  features.append({
                      "type": "Feature",
                      "geometry": gj_geom,
                      "properties": f.get("attributes", {}),
                  })
              
              return {"type": "FeatureCollection", "features": features}

          # =============================================================================
          # Fetchers
          # =============================================================================

          def fetch_cwfis(layer: str, label: str) -> dict:
              """Fetch from CWFIS WFS with NB bbox filter."""
              minx, miny, maxx, maxy = NB_BBOX
              
              params = {
                  "service": "WFS",
                  "version": "1.0.0",
                  "request": "GetFeature",
                  "typeName": layer,
                  "srsName": "EPSG:4326",
                  "bbox": f"{minx},{miny},{maxx},{maxy},EPSG:4326",
                  "outputFormat": "application/json",
              }
              
              data = fetch_json(CWFIS_WFS, params, label)
              
              if data.get("features"):
                  return data
              
              # Fallback: try CQL filter
              params.pop("bbox")
              params["CQL_FILTER"] = f"BBOX(the_geom,{minx},{miny},{maxx},{maxy})"
              data = fetch_json(CWFIS_WFS, params, f"{label} (CQL)")
              
              return data if data.get("features") else empty_fc()

          def fetch_erd(url: str, label: str) -> dict:
              """Fetch from ERD ArcGIS with NB bbox filter."""
              minx, miny, maxx, maxy = NB_BBOX
              
              # Try spatial filter first
              params = {
                  "where": "1=1",
                  "geometryType": "esriGeometryEnvelope",
                  "geometry": f"{minx},{miny},{maxx},{maxy}",
                  "inSR": 4326,
                  "spatialRel": "esriSpatialRelIntersects",
                  "outFields": "*",
                  "returnGeometry": "true",
                  "outSR": 4326,
                  "f": "json",
                  "resultRecordCount": 2000,
              }
              
              data = fetch_json(url, params, label)
              
              if data.get("error"):
                  log(f"  {label}: ArcGIS error - {data['error']}")
              elif data.get("features"):
                  return esri_to_geojson(data)
              
              # Fallback: all features
              params = {
                  "where": "1=1",
                  "outFields": "*",
                  "returnGeometry": "true",
                  "outSR": 4326,
                  "f": "json",
              }
              data = fetch_json(url, params, f"{label} (all)")
              
              return esri_to_geojson(data) if data.get("features") else empty_fc()

          def write_json(path: str, data: dict) -> None:
              os.makedirs(os.path.dirname(path), exist_ok=True)
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(data, f, ensure_ascii=False)
                  f.write("\n")
              log(f"  Wrote {path}")

          # =============================================================================
          # Main
          # =============================================================================

          today = datetime.now(ATLANTIC_TZ).strftime("%Y%m%d")
          archived_at = datetime.now(ATLANTIC_TZ).strftime("%Y-%m-%d %H:%M:%S %Z")

          log(f"Archiving data for {today}")
          log(f"NB bbox: {NB_BBOX}")

          os.makedirs(CWFIS_DIR, exist_ok=True)
          os.makedirs(ERD_DIR, exist_ok=True)

          failures = []

          for name, config in DATASETS.items():
              log(f"Processing {name}...")
              
              try:
                  if config["type"] == "cwfis":
                      data = fetch_cwfis(config["layer"], name)
                  else:
                      data = fetch_erd(config["url"], name)
                  
                  data["archived_at"] = archived_at
                  
                  output = os.path.join(config["dir"], f"{name}_{today}.geojson")
                  write_json(output, data)
                  
                  log(f"  Features: {len(data.get('features', []))}")
                  
              except Exception as e:
                  log(f"  FAILED: {e}")
                  failures.append(name)

          if failures:
              log(f"Failures: {failures}")
              raise SystemExit(1)

          log("Done")

      - name: Commit and push
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config pull.rebase true
          
          if [ -n "$(git status --porcelain archive/)" ]; then
            git add archive/
            git commit -m "Archived $(TZ=America/Moncton date +'%Y/%m/%d %I:%M %p')"
            
            for i in 1 2 3; do
              if git push origin "HEAD:$BRANCH_NAME"; then
                exit 0
              fi
              echo "Push failed (attempt $i), rebasing..."
              git fetch origin "$BRANCH_NAME"
              git pull --rebase origin "$BRANCH_NAME" || true
              sleep 2
            done
            
            echo "Push failed after 3 attempts"
            exit 1
          else
            echo "No changes to commit"
          fi

      - name: Upload archive artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: geojson-archive
          path: archive/**/*.geojson
          if-no-files-found: ignore
